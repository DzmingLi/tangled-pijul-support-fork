// Code generated by cmd/lexgen (see Makefile's lexgen); DO NOT EDIT.

package tangled

// schema: sh.tangled.repo.pijulBlob

import (
	"context"

	"github.com/bluesky-social/indigo/lex/util"
)

const (
	RepoPijulBlobNSID = "sh.tangled.repo.pijulBlob"
)

// RepoPijulBlob_Output is the output of a sh.tangled.repo.pijulBlob call.
type RepoPijulBlob_Output struct {
	// contents: File contents (empty for binary files)
	Contents *string `json:"contents,omitempty" cborgen:"contents,omitempty"`
	// is_binary: Whether the file is binary
	Is_binary bool `json:"is_binary" cborgen:"is_binary"`
	// path: File path
	Path string `json:"path" cborgen:"path"`
	// ref: Channel name
	Ref *string `json:"ref,omitempty" cborgen:"ref,omitempty"`
}

// RepoPijulBlob calls the XRPC method "sh.tangled.repo.pijulBlob".
//
// channel: Pijul channel name (defaults to main channel)
// path: Path to the file within the repository
// repo: Repository identifier in format 'did:plc:.../repoName'
func RepoPijulBlob(ctx context.Context, c util.LexClient, channel string, path string, repo string) (*RepoPijulBlob_Output, error) {
	var out RepoPijulBlob_Output

	params := map[string]interface{}{}
	if channel != "" {
		params["channel"] = channel
	}
	params["path"] = path
	params["repo"] = repo
	if err := c.LexDo(ctx, util.Query, "", "sh.tangled.repo.pijulBlob", params, nil, &out); err != nil {
		return nil, err
	}

	return &out, nil
}
